name: Deploy to Production (Secure)

on:
  push:
    branches: [ main, production ]
  workflow_dispatch:

env:
  VPS_HOST: ${{ secrets.VPS_HOST }}
  VPS_USER: ${{ secrets.VPS_USER }}
  DEPLOY_PATH: ${{ secrets.DEPLOY_PATH }}

jobs:
  deploy:
    name: Deploy to VPS
    runs-on: ubuntu-latest
    environment: production  # GitHub Environment pour protection supplémentaire
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup SSH
      uses: webfactory/ssh-agent@v0.8.0
      with:
        ssh-private-key: ${{ secrets.VPS_SSH_PRIVATE_KEY }}
        
    - name: Add VPS to known hosts
      run: |
        ssh-keyscan -H ${{ env.VPS_HOST }} >> ~/.ssh/known_hosts
        
    - name: Deploy files to VPS
      run: |
        rsync -avz --delete \
          --exclude='.git' \
          --exclude='node_modules' \
          --exclude='*.log' \
          --exclude='.dart_tool' \
          --exclude='build' \
          --exclude='.env*' \
          --exclude='config/passwords.yaml' \
          --exclude='**/secrets' \
          --exclude='postgres_data' \
          --exclude='redis_data' \
          --exclude='caddy_data' \
          --exclude='caddy_config' \
          ./ ${{ env.VPS_USER }}@${{ env.VPS_HOST }}:${{ env.DEPLOY_PATH }}/
          
    - name: Configure environment and deploy
      env:
        DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
        REDIS_PASSWORD: ${{ secrets.REDIS_PASSWORD }}
        API_DOMAIN: ${{ secrets.API_DOMAIN }}
        INSIGHTS_DOMAIN: ${{ secrets.INSIGHTS_DOMAIN }}
        WEB_DOMAIN: ${{ secrets.WEB_DOMAIN }}
        LETSENCRYPT_EMAIL: ${{ secrets.LETSENCRYPT_EMAIL }}
      run: |
        ssh ${{ env.VPS_USER }}@${{ env.VPS_HOST }} << 'ENDSSH'
          set -e
          cd ${{ env.DEPLOY_PATH }}
          
          # Create .env file from secrets
          cat > .env << EOF
DB_PASSWORD="${DB_PASSWORD}"
REDIS_PASSWORD="${REDIS_PASSWORD}"
API_DOMAIN="${API_DOMAIN}"
INSIGHTS_DOMAIN="${INSIGHTS_DOMAIN}"
WEB_DOMAIN="${WEB_DOMAIN}"
LETSENCRYPT_EMAIL="${LETSENCRYPT_EMAIL}"
ENVIRONMENT=production
PORT=8080
EOF
          
          # Create Serverpod passwords.yaml from secrets
          mkdir -p config
          cat > config/passwords.yaml << EOF
production:
  database: '${DB_PASSWORD}'
  redis: '${REDIS_PASSWORD}'
EOF
          
          # Set proper permissions (security)
          chmod 600 .env config/passwords.yaml
          
          # Build with BuildKit for better caching
          export DOCKER_BUILDKIT=1
          docker compose -f docker-compose.production.yml build --no-cache timesheet-backend
          
          # Health check function
          wait_for_service() {
            local service=$1
            local max_attempts=30
            local attempt=0
            
            while [ $attempt -lt $max_attempts ]; do
              if docker compose -f docker-compose.production.yml exec -T $service echo "OK" 2>/dev/null; then
                echo "✅ $service is ready"
                return 0
              fi
              echo "Waiting for $service... ($attempt/$max_attempts)"
              sleep 2
              attempt=$((attempt + 1))
            done
            
            echo "❌ $service failed to start"
            return 1
          }
          
          # Start services with health checks
          docker compose -f docker-compose.production.yml up -d postgres redis
          wait_for_service postgres
          wait_for_service redis
          
          # Run migrations safely
          echo "Running database migrations..."
          for migration in migrations/*/migration.sql; do
            if [ -f "$migration" ]; then
              migration_name=$(basename $(dirname $migration))
              echo "Applying migration: $migration_name"
              
              # Check if migration was already applied
              if docker exec -e PGPASSWORD="${DB_PASSWORD}" timesheet-postgres \
                psql -U postgres -d time_sheet_backend -tAc \
                "SELECT 1 FROM serverpod_migrations WHERE module='time_sheet_backend' AND version='$migration_name'" 2>/dev/null | grep -q 1; then
                echo "Migration $migration_name already applied, skipping..."
              else
                cat "$migration" | docker exec -i -e PGPASSWORD="${DB_PASSWORD}" \
                  timesheet-postgres psql -U postgres -d time_sheet_backend || {
                    echo "Migration $migration_name failed!"
                    exit 1
                  }
              fi
            fi
          done
          
          # Start application services
          docker compose -f docker-compose.production.yml up -d timesheet-backend caddy
          
          # Wait for services to be healthy
          wait_for_service timesheet-backend
          
          # Verify deployment
          sleep 5
          if curl -f -I https://${API_DOMAIN}/ >/dev/null 2>&1; then
            echo "✅ Deployment successful! API is responding."
          else
            echo "⚠️ API not responding on HTTPS yet, checking HTTP..."
            curl -I http://localhost:8080/ || echo "❌ Backend not responding"
          fi
          
          # Clean sensitive files from environment
          unset DB_PASSWORD REDIS_PASSWORD
        ENDSSH
        
    - name: Cleanup and monitoring
      if: always()
      run: |
        ssh ${{ env.VPS_USER }}@${{ env.VPS_HOST }} << 'ENDSSH'
          cd ${{ env.DEPLOY_PATH }}
          
          # Show service status
          echo "=== Service Status ==="
          docker compose -f docker-compose.production.yml ps
          
          # Clean up
          docker image prune -f >/dev/null 2>&1
          docker builder prune -f >/dev/null 2>&1
          
          # Keep only last 5 backups
          ls -t backup_*.sql 2>/dev/null | tail -n +6 | xargs rm -f 2>/dev/null || true
          
          # Show recent logs (without sensitive data)
          echo "=== Recent Backend Logs ==="
          docker logs timesheet-backend --tail 10 2>&1 | grep -v password || true
        ENDSSH
        
    - name: Send deployment notification
      if: always()
      uses: actions/github-script@v6
      with:
        script: |
          const status = '${{ job.status }}';
          const emoji = status === 'success' ? '✅' : '❌';
          const message = `${emoji} Deployment ${status} for commit ${context.sha.substring(0, 7)}`;
          
          // Create deployment status
          await github.rest.repos.createDeploymentStatus({
            owner: context.repo.owner,
            repo: context.repo.repo,
            deployment_id: context.payload.deployment?.id || 1,
            state: status === 'success' ? 'success' : 'failure',
            environment_url: status === 'success' ? 'https://${{ secrets.API_DOMAIN }}' : '',
            description: message
          }).catch(err => console.log('Could not create deployment status'));
          
          console.log(message);