name: Deploy to Contabo VPS

on:
  push:
    branches: [ main, production ]
  workflow_dispatch:

env:
  VPS_HOST: ${{ secrets.VPS_HOST }}
  VPS_USER: ${{ secrets.VPS_USER }}
  DEPLOY_PATH: ${{ secrets.DEPLOY_PATH }}

jobs:
  deploy:
    name: Deploy to Contabo VPS
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup SSH
      uses: webfactory/ssh-agent@v0.8.0
      with:
        ssh-private-key: ${{ secrets.VPS_SSH_PRIVATE_KEY }}
        
    - name: Add VPS to known hosts
      run: |
        ssh-keyscan -H ${{ env.VPS_HOST }} >> ~/.ssh/known_hosts
        
    - name: Deploy files to VPS
      run: |
        rsync -avz --delete \
          --exclude='.git' \
          --exclude='node_modules' \
          --exclude='*.log' \
          --exclude='.dart_tool' \
          --exclude='build' \
          --exclude='.env*' \
          --exclude='config/passwords.yaml' \
          --exclude='postgres_data' \
          --exclude='redis_data' \
          --exclude='caddy_data' \
          --exclude='caddy_config' \
          ./ ${{ env.VPS_USER }}@${{ env.VPS_HOST }}:${{ env.DEPLOY_PATH }}/
          
    - name: Configure environment and deploy
      run: |
        # Export variables before SSH pour les passer correctement
        export DB_PASSWORD="${{ secrets.DB_PASSWORD }}"
        export REDIS_PASSWORD="${{ secrets.REDIS_PASSWORD }}"
        export API_DOMAIN="${{ secrets.API_DOMAIN }}"
        export INSIGHTS_DOMAIN="${{ secrets.INSIGHTS_DOMAIN }}"
        export WEB_DOMAIN="${{ secrets.WEB_DOMAIN }}"
        export LETSENCRYPT_EMAIL="${{ secrets.LETSENCRYPT_EMAIL }}"
        
        # Passer le DEPLOY_PATH comme variable
        ssh ${{ env.VPS_USER }}@${{ env.VPS_HOST }} "DEPLOY_PATH='${{ env.DEPLOY_PATH }}' DB_PASSWORD='${{ secrets.DB_PASSWORD }}' REDIS_PASSWORD='${{ secrets.REDIS_PASSWORD }}' API_DOMAIN='${{ secrets.API_DOMAIN }}' INSIGHTS_DOMAIN='${{ secrets.INSIGHTS_DOMAIN }}' WEB_DOMAIN='${{ secrets.WEB_DOMAIN }}' LETSENCRYPT_EMAIL='${{ secrets.LETSENCRYPT_EMAIL }}' bash -s" << 'ENDSSH'
          set -e
          cd ${DEPLOY_PATH}
          
          # Recevoir les variables depuis l'environnement SSH
          DB_PASSWORD="${DB_PASSWORD:-D3fPoHe2kANkIBLhARsxX3XyqtzZVS7g}"
          REDIS_PASSWORD="${REDIS_PASSWORD:-_C0f52i_lp0gETHNnCMs4iIK1BfeKy-W}"
          API_DOMAIN="${API_DOMAIN:-api-timesheet.wefamily.ch}"
          INSIGHTS_DOMAIN="${INSIGHTS_DOMAIN:-insights.wefamily.ch}"
          WEB_DOMAIN="${WEB_DOMAIN:-app.wefamily.ch}"
          LETSENCRYPT_EMAIL="${LETSENCRYPT_EMAIL:-admin@wefamily.ch}"
          
          # Create .env file
          cat > .env << ENVFILE
DB_PASSWORD=${DB_PASSWORD}
REDIS_PASSWORD=${REDIS_PASSWORD}
API_DOMAIN=${API_DOMAIN}
INSIGHTS_DOMAIN=${INSIGHTS_DOMAIN}
WEB_DOMAIN=${WEB_DOMAIN}
LETSENCRYPT_EMAIL=${LETSENCRYPT_EMAIL}
ENVIRONMENT=production
PORT=8080
ENVFILE
          
          # Create Serverpod passwords.yaml
          mkdir -p config
          cat > config/passwords.yaml << PASSFILE
production:
  database: '${DB_PASSWORD}'
  redis: '${REDIS_PASSWORD}'
PASSFILE
          
          # Set proper permissions
          chmod 600 .env config/passwords.yaml
          
          # Build
          docker compose -f docker-compose.production.yml build --no-cache timesheet-backend
          
          # Start services
          docker compose -f docker-compose.production.yml up -d postgres redis
          
          # Wait for postgres
          echo "Waiting for PostgreSQL..."
          for i in {1..30}; do
            if docker exec timesheet-postgres pg_isready -U postgres 2>/dev/null; then
              echo "PostgreSQL is ready"
              break
            fi
            echo "Waiting... ($i/30)"
            sleep 2
          done
          
          # Run migrations
          echo "Running database migrations..."
          for migration in migrations/*/migration.sql; do
            if [ -f "$migration" ]; then
              echo "Applying: $(basename $(dirname $migration))"
              cat "$migration" | docker exec -i -e PGPASSWORD="${DB_PASSWORD}" \
                timesheet-postgres psql -U postgres -d time_sheet_backend 2>&1 | \
                grep -E "(BEGIN|COMMIT|CREATE|ALTER|INSERT|already exists)" || true
            fi
          done
          
          # Start application
          docker compose -f docker-compose.production.yml up -d timesheet-backend caddy
          
          # Verify
          sleep 10
          echo "=== Service Status ==="
          docker ps --format "table {{.Names}}\t{{.Status}}"
          
          # Test API
          echo "=== Testing API ==="
          if curl -f -I https://${API_DOMAIN}/ 2>/dev/null; then
            echo "✅ API is responding on HTTPS"
          else
            echo "Testing HTTP..."
            curl -I http://localhost:8080/ || echo "⚠️ Backend might need more time"
          fi
        ENDSSH
        
    - name: Cleanup
      if: always()
      run: |
        ssh ${{ env.VPS_USER }}@${{ env.VPS_HOST }} "DEPLOY_PATH='${{ env.DEPLOY_PATH }}' bash -s" << 'ENDSSH'
          cd ${DEPLOY_PATH}
          
          # Clean up
          docker image prune -f 2>/dev/null || true
          
          # Show logs without sensitive data
          echo "=== Recent Logs ==="
          docker logs timesheet-backend --tail 10 2>&1 | grep -v password || true
        ENDSSH